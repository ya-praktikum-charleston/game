<?php include '../include/header.php'; ?>



<div class="linear" id="Hello">

    <h2>Введение в алгоритмы</h2>

    <h2>Основные функции сложности</h2>

    <p><b>Константная сложность О(1)</b></p>

    <p>Сложность алгоритма не зависит от входных данных.</p>

    <p>Пример – целочисленное деление.</p>

    <pre class="brush: js;">
        function div(a, b) {
            return (a - (a % b)) / b;
        }
    </pre>

    <p>Вне зависимости от значений <code>a</code> и <code>b</code> объем работы не меняется.</p>

    <br>

    <p><b>Логарифмическая сложность О(log(n))</b></p>

    <p>Сложность растёт логарифмически – на каждом шаге мы уменьшаем количество обрабатываемых данных в несколько раз. В информатике часто работают с логарифмами по основанию два. Значит, что уменьшают объём данных вдвое. Но на сложность алгоритма основание не влияет.</p>

    <p>Пример – бинарный поиск индекса элемента по отсортированному массиву. Суть в том, что на каждом шаге мы берем элемент из середины отсортированного массива и проверяем, равен ли он искомому. Если он больше, продолжаем искать в левой части. Если меньше – в правой. И так до тех пор, пока не найдём.</p>

    <pre class="brush: js;">
        function binarySearch(sortedNumbers, n) {
            // Определяем точки начала и конца поиска
          let start = 0;
          let end = sortedNumbers.length;

          while (start < end) {
                // Находим элемент в середине массива
            const middle = Math.floor((start + end) / 2);
            const value = sortedNumbers[middle];

                // Сравниваем аргумент со значением в середине массива
            if (n == value) {
              return middle;
            }

                // Если аргумент меньше, чем серединное значение, разделяем массив пополам
                // Теперь конец массива — это его бывшая середина
            if (n < value) {
              end = middle;
                // Иначе началом массива становится элемент, идущий сразу за «серединой»
            } else {
              start = middle + 1;
            }
          }

          // если искомое число не найдено, возвращаем -1
          return -1;
        }
    </pre>

    <p>При каждой итерации массив делится пополам. Если изначально длина массива, например, 1024, то на второй итерации элементов останется 512, затем — 256, потом 128 и так далее.</p>

    <p>Таким образом, для массива размера 1024 понадобится максимум <code>log2(1024)</code> = 10 шагов. И число шагов будет расти очень медленно по сравнению с ростом размера массива. Например, чтобы найти число в отсортированном массиве размером в 1000 раз больше, понадобится всего в 2 раза больше шагов <code>log2(1024000) = 19.96</code>.</p>

    <br>
    <p><b>Линейная сложность О(n)</b></p>

    <p>Сложность растёт прямо пропорционально росту данных. Получаем эту сложность всегда, когда создаём цикл по коллекции элементов.</p>

    <p>Пример – нахождение минимума/максимума в несортированном массиве. Здесь мы идём по массиву и сравниваем числа. Если встречаем больше или меньше записанного минимума и максимума, перезаписываем их на новые.</p>

    <pre class="brush: js;">
    function minMax(numbers) {
        // Присваиваем переменным min и max первый элемент массива
        let min = numbers[0];
        let max = numbers[0];

        for (let i = 1; i < numbers.length; i++) {
            const n = numbers[i];
        // Сравниваем элемент с min
            if (n < min) {
                min = n;
            }
        // Сравниваем элемент с max
            if (n > max) {
                max = n;
            }
        }
        // Возвращаем найденную пару значений
        return {min, max};
    }
    </pre>

    <p>Количество операций линейно зависит от длины массива. Если массив увеличится вдвое, то и количество операций увеличится вдвое. Это и есть линейная зависимость.</p>

    <br>
    <p><b>Линейно логарифмическая сложность О(n*log(n))</b></p>

    <p>Растёт быстрее линейной, но медленнее квадратичной. Мы рассмотрим пример алгоритма с такой сложностью на практике в следующем уроке.</p>

    <p>Пример – нахождение пересечения двух массивов. Ищем общие элементы в массивах <code>arr1</code> и <code>arr2</code>. Для этого запускаем цикл по всем элементам массива, бинарным поиском ищем каждый элемент первого массива во втором.</p>

    <pre class="brush: js;">
        function intersection(arr1, arr2) {
            // Заводим массив для результата
            const elements = [];

            for (let i = 0; i < arr1.length; i++) {
                // Запускаем бинарный поиск элемента с индексом i из первого массива во втором
                const found = binarySearch(arr2, arr1[i]);

                // Если элемент найден, добавляем его в результат
                if (found > -1) {
                    elements.push(arr1[i]);
                }
            }

            // Возвращаем результат
            return elements;
        }
    </pre>

    <p>Внутри основного цикла по по массиву <code>arr1</code> мы воспользовались бинарным поиском по массиву <code>arr2</code>. Обозначим размер <code>arr1</code> как <code>n</code>, размер <code>arr2</code> как <code>m</code>. Тогда сложность бинарного поиска по <code>arr2</code> будет <code>O(log(m))</code>. При этом мы запускаем его <code>n</code> раз в цикле по массиву <code>arr1</code>. Поэтому сложность алгоритма будет <code>O(n*log(m))</code>, где <code>n</code> – размер первого массива, <code>m</code> – размер второго.</p>

    <br>
    <p><b>Квадратичная сложность O(n^2)</b></p>

    <p>Квадратичная сложность растёт быстро, ведь при увеличении данных в 100 раз, объём вычислений вырастет в 10000 раз. Поэтому алгоритм с такой сложностью на больших данных работает медлен</p>

    <p>Пример – поиск всех комбинаций элементов из двух массивов. Для каждого элемента из первого массива мы пробегаем по всему второму массиву, складывая все пары в результирующий массив.</p>

    <pre class="brush: js;">
        function combinations(arr1, arr2) {
            // Создаём массив для результата
          const result = [];

            // Запускаем вложенные циклы и формируем все возможные пары
          for (let i = 0; i < arr1.length; i++) {
            for (let j = 0; j < arr2.length; j++) {
              result.push([arr1[i], arr2[j]]);
            }
          }

          return result;
        }
    </pre>

    <p>Квадратичная сложность — частный случай полиномиальной — <code>O(n^k)</code>. Если цикл вложен в другой цикл, а тот — в третий, зависимость будет кубической — <code>O(n^3)</code>. Если 4 массива вложены друг в друга — <code>O(n^4)</code>. И так далее.</p>

    <br>
    <p><b>Экспоненциальная сложность О(2^n)</b></p>

    <p>Растёт быстрее любого полинома. Лучше найти другое решение, хотя в некоторых алгоритмах экспоненциальная сложность приемлема, потому что решений с более низкой сложностью для них не существует. Возникает в рекурсивных алгоритмах, где на каждом шаге количество обрабатываемых данных уменьшается менее чем вдвое.</p>

    <p>Пример – нахождение n-го числа Фибоначчи. Принимаем номер искомого числа Фибоначчи. Если это первое или второе число, возвращаем <code>n</code>, которое равно 1. Если число больше 1, вычисляем как сумму двух предыдущих и возвращаем результат.</p>

    <pre class="brush: js;">
        // Ряд Фиббоначи — это 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...
        function fibonacci(n) {
            if (n <= 1) return n;
            return fibonacci(n - 2) + fibonacci(n - 1);
        }
    </pre>

    <p>Здесь для каждого числа мы запускаем алгоритм заново на числах, меньших текущего на единицу и на двойку. Можно считать, что сложность расчёта <code>n</code>-го члена равна <code>О(f(n)) = О(f(n-1)) + О(f(n-2))</code> Предположим, что сложность расчёта <code>f(n-2)</code> примерно равна сложности расчёта <code>f(n-1)</code>, хотя на самом деле она будет чуть ниже. Получим <code>О(f(n)) = 2О(f(n-1)) = 4О(f(n-2)) = 8О(f(n-3)) = ... = 2^n*О(n-n) = О(2^n)</code>.</p>

    <br>
    <p><b>Факториальная сложность О(n!)</b></p>

    <p>Функция растёт быстрее всех рассмотренных. Обычно возникает в комбинаторных задачах, где перебирают варианты вида «все со всеми» и проверяют соответствие условию.</p>

    <p>Пример – нахождение количества перестановок в массиве. Принимаем на вход массив. Для каждого элемента создаём копию массива без этого элемента, и запускаем алгоритм на ней заново, помещая удалённый элемент в накопительный массив, содержащий текущую перестановку.</p>

    <pre class="brush: js;">
        function permutations(arr, perm = [], result = []) {
            // если элементов не осталось - возвращаем текущую перестановку
            if (arr.length === 0) {
                result.push(perm);
            } else {
                for (let i = 0; i < arr.length; i++) {
                    // создаем копию массива
                    const copy = arr.slice();
                    // убираем из него текущий элемент
                    const elem = copy.splice(i, 1);
                    // запускаем алгоритм заново на копии,
                    // добавив текущий элемент в массив с перестановками
                    permutations(copy, perm.concat(elem), result);
                }
            }

            return result;
        }
    </pre>

    <p><b>Практика</b></p>

    <p><b>Задача 1 - Реализация массива</b></p>

    <pre class="brush: js;">
        class MyArray {
            constructor(initialSize = 1) {
                if (Number(initialSize) !== initialSize || Math.round(initialSize) !== initialSize) {
                    throw new Error('Длина массива должна быть целым числом');
                }

                if (!(initialSize > 0)) {
                    throw new Error('Размер массива должен быть больше нуля');
                }

                this.size = initialSize;
                this.memory = allocate(initialSize);
                this.length = 0;

            }

            ifError(index) {
                if(index === undefined || index < 0 || index >= this.length){
                    throw new Error('Размер массива меньше индекса');
                }
            }

            // Возвращает значение по индексу.
            // Если индекс за пределами — кидает ошибку.
            get(index){
                this.ifError(index);
                return this.memory[index];
            }

            // Устанавливает значение по индексу.
            // Если индекс за пределами — кидает ошибку.
            set(index, value) {
                this.ifError(index);
                this.memory[index] = value;
            }

            // Добавляет новый элемент в массив.
            // Если index не определён — добавляет в конец массива.
            // В противном случае — добавляет по индексу со сдвигом
            // всех последующих элементов.
            // Если индекс за пределами - кидает ошибку.
            // Увеличивает выделенную память вдвое, если необходимо.
            // Возвращает новую длину массива.
            add(value, index) {

                index && this.ifError(index);

                if(index || index === 0){
                    for(let i = this.length; i > index; i--){
                        this.memory[i] = this.memory[i-1];
                    }
                    this.memory[index] = value;
                    this.length++;
                }else{
                    this.memory[this.length] = value;
                    this.length++;
                }

                let leng = this.length;

                if(this.size === this.length){
                    for(let i = leng; i < leng * 2; i++){
                        this.memory[i] = undefined;
                        this.size++;
                    }
                }
                console.log(this.length);
                console.log(this.size);
                console.log("memory",this.memory)
                return this.length;
            }

            // Удаляет элемент по индексу со сдвигом всех последующих элементов.
            // Если индекс за пределами - кидает ошибку.
            // Возвращает новую длину массива.
            delete(index) {
                this.ifError(index);

                for(let i = index; i <= this.length-1; i++){
                    if(i === this.length-1){
                        delete this.memory[i];
                        delete this.memory[i+1];
                    }else{
                        this.memory[i] = this.memory[i+1];
                    }
                }

                --this.length;
                console.log(this.length);
                console.log(this.size);
                console.log("memory",this.memory)
                return this.length;
            }


        }


        function allocate(size) {
            const memory = {};

            for (let i = 0; i < size; i++) {
                memory[i] = undefined;
            }

            return memory;
        }

        let arr = new MyArray;
        arr.add('a');
        arr.add('b');
        arr.add('c');
        arr.add('d');

        //arr.set(1,'oop');
        arr.delete(2);

    </pre>

    <br>
    <h2>Практика</h2>

    <p><b>Задача 1 - Бинарный поиск</b></p>

    <p>Напишите функцию, которая найдёт заданный элемент в отсортированном массиве и вернёт позицию его первого вхождения. Если элемент не найден — верните -1.</p>

    <p>Функция получает в качестве аргументов отсортированный по возрастанию массив и заданный элемент. В решении используйте бинарный поиск.</p>

    <pre class="brush: js;">
        const list = [1, 3, 4, 5, 7, 10];

        function binarySearch(list, n) {
            // Определяем точки начала и конца поиска
            let start = 0;
            let end = list.length;

            while (start < end) {
                // Находим элемент в середине массива
                const middle = Math.floor((start + end) / 2);
                const value = list[middle];

                // Сравниваем аргумент со значением в середине массива
                if (n == value) {
                    console.log(middle)
                    return middle;
                }

                // Если аргумент меньше, чем серединное значение, разделяем массив пополам
                // Теперь конец массива — это его бывшая середина
                if (n < value) {
                    end = middle;
                    // Иначе началом массива становится элемент, идущий сразу за «серединой»
                } else {
                    start = middle + 1;
                }
            }

            // если искомое число не найдено, возвращаем -1
            console.log('-1')
            return -1;
        }

        binarySearch(list ,2);
        binarySearch(list, 3);
    </pre>

    <br>
    <p><b>Задача 2 - Палиндром</b></p>

    <p>Палиндром — последовательность символов, которая одинаково пишется в обоих направлениях. К примеру, “Anna” — палиндром, а “table” — нет.</p>

    <p>Создайте функцию <code>palindrome</code>, которая принимает строку и возвращает <code>true</code>, если строка — палиндром. В противном случае функция должна вернуть <code>false</code>.</p>

    <pre class="brush: js;">
        // palindrome('racecar') === true;
        // palindrome('table') === false;

        const palindrome = (str) => {
            str = str.toLowerCase();
            if(str === str.split('').reverse().join('')) {
                return true;
            }else {
                return false;
            }
        };

        palindrome('Anna');
        palindrome('racecar');
        palindrome('table');
    </pre>

    <br>
    <p><b>Задача 2 - FizzBuzz</b></p>

    <p>Напишите функцию, которая принимает целое число N в качестве аргумента и возвращает числа от 0 до N. При этом функция заменяет некоторые числа:</p>

    <ul class="marker">
        <li>вместо чисел, кратных 3, вернёт 'fizz',</li>
        <li>кратных 5 — вернёт 'buzz',</li>
        <li>кратных и 3, и 5 — вернёт 'fizzbuzz'.</li>
    </ul>

    <pre class="brush: js;">
        // fizzBuzz(6) => [0, 1, 2, fizz, 4, buzz, fizz]

        const fizzBuzz = num => {
            const arr = [];
            for (let i = 0; i <= num; i++) {
                if(i === 0){
                    arr.push(0);
                }else if (i % 3 === 0 && i % 5 === 0) {
                    arr.push('fizzbuzz');
                } else if (i % 5 === 0) {
                    arr.push('buzz');
                } else if (i % 3 === 0) {
                    arr.push('fizz');
                } else {
                    arr.push(i);
                }
            }

            return arr;
        }

        fizzBuzz(6);
    </pre>


</div>


<!--
<pre class="brush: js;">

</pre>

v&ndash;                тире

&quot;                  двойная кавычка

-->


<!--

<div class="linear" id="use_strict">
    <h1>Строгий режим — "use strict"</h1>

    <h2>«use strict»</h2>


    <p>Например:</p>

    <pre class="brush: js;">
            "use strict";

            // этот код работает в современном режиме
            ...
        </pre>


    <p>На данный момент достаточно иметь общее понимание об этом режиме:</p>
    <ul class="ul_num">
        <li><code>111111</code> 2222222222222222</li>

    </ul>

</div>

-->



<?php include '../include/footer.php'; ?>
